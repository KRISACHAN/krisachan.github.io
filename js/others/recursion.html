<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>记一次递归在我项目中所发挥的作用 | 鱼头的Web海洋</title>
    <meta name="description" content="让你的Web学习如同玩耍在海洋一样快乐" />
    <link rel="icon" href="https://fish-pond-1253945200.cos.ap-guangzhou.myqcloud.com/base/blogfavicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.a57752fc.css" as="style"><link rel="preload" href="/assets/js/app.2b0bb46a.js" as="script"><link rel="preload" href="/assets/js/33.537cee41.js" as="script"><link rel="prefetch" href="/assets/js/18.a48f8075.js"><link rel="prefetch" href="/assets/js/2.ee28eecc.js"><link rel="prefetch" href="/assets/js/3.107d2854.js"><link rel="prefetch" href="/assets/js/4.7648d62c.js"><link rel="prefetch" href="/assets/js/5.373cc625.js"><link rel="prefetch" href="/assets/js/6.c8c69fdc.js"><link rel="prefetch" href="/assets/js/7.ce3e1a47.js"><link rel="prefetch" href="/assets/js/8.5637ce93.js"><link rel="prefetch" href="/assets/js/9.9adb8b39.js"><link rel="prefetch" href="/assets/js/10.124013aa.js"><link rel="prefetch" href="/assets/js/11.23af6432.js"><link rel="prefetch" href="/assets/js/12.744b9a6d.js"><link rel="prefetch" href="/assets/js/13.6c4936b3.js"><link rel="prefetch" href="/assets/js/14.a1a9539d.js"><link rel="prefetch" href="/assets/js/15.b4bafa42.js"><link rel="prefetch" href="/assets/js/16.aa208852.js"><link rel="prefetch" href="/assets/js/17.185fde70.js"><link rel="prefetch" href="/assets/js/19.bee79bfe.js"><link rel="prefetch" href="/assets/js/20.fa7fdb2e.js"><link rel="prefetch" href="/assets/js/21.56ac4292.js"><link rel="prefetch" href="/assets/js/22.811a01c3.js"><link rel="prefetch" href="/assets/js/23.ce7665de.js"><link rel="prefetch" href="/assets/js/24.0d3190c6.js"><link rel="prefetch" href="/assets/js/25.840592a0.js"><link rel="prefetch" href="/assets/js/26.b5a78a0b.js"><link rel="prefetch" href="/assets/js/27.f06c2b81.js"><link rel="prefetch" href="/assets/js/28.c86d9301.js"><link rel="prefetch" href="/assets/js/29.2b3bf1fe.js"><link rel="prefetch" href="/assets/js/30.83cb4ea8.js"><link rel="prefetch" href="/assets/js/31.d8e1d035.js"><link rel="prefetch" href="/assets/js/32.f75dbc0f.js"><link rel="prefetch" href="/assets/js/34.84b0d1ce.js"><link rel="prefetch" href="/assets/js/35.49b5285c.js"><link rel="prefetch" href="/assets/js/36.f6633375.js"><link rel="prefetch" href="/assets/js/37.78811184.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a57752fc.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">鱼头的Web海洋</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><!----> <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>记一次递归在我项目中所发挥的作用</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/js/others/recursion.html#背景" class="sidebar-link">背景</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/js/others/recursion.html#什么是递归" class="sidebar-link">什么是递归</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/js/others/recursion.html#递归怎么写？" class="sidebar-link">递归怎么写？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/js/others/recursion.html#功能实现" class="sidebar-link">功能实现</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/js/others/recursion.html#分步实现" class="sidebar-link">分步实现</a></li><li class="sidebar-sub-header"><a href="/js/others/recursion.html#完整代码" class="sidebar-link">完整代码</a></li><li class="sidebar-sub-header"><a href="/js/others/recursion.html#备注：函数体积好大呀，但这只是业务里的一个小小小功能，流下了不会优化代码的泪水" class="sidebar-link">备注：函数体积好大呀，但这只是业务里的一个小小小功能，流下了不会优化代码的泪水~</a></li></ul></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="记一次递归在我项目中所发挥的作用"><a href="#记一次递归在我项目中所发挥的作用" aria-hidden="true" class="header-anchor">#</a> 记一次递归在我项目中所发挥的作用</h1> <blockquote><ul><li>作者：陈大鱼头</li> <li>github： <a href="https://github.com/KRISACHAN" target="_blank" rel="noopener noreferrer">KRISACHAN<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></blockquote> <h2 id="背景"><a href="#背景" aria-hidden="true" class="header-anchor">#</a> 背景</h2> <p>在最近的项目中，有这么一个功能点，就是要获取在WEB IDE里用户所写的注释中的一段特殊规则，然后解析成一段JS config 对象
<br>
例如：
<br></p> <div class="language- extra-class"><pre class="language-text"><code>//% width=&quot;100px&quot; height=&quot;200px&quot;
//% pos.top=&quot;50px&quot; pos.left=&quot;50px&quot;
//% writable=true
//% q.b.d.w.r.f=30 q.b.d.w.r.a=40
</code></pre></div><p>要转成</p> <div class="language- extra-class"><pre class="language-text"><code>{
    width: '100px',
    height: '200px',
    pos: {
        top: '50px',
        left: '50px'
    },
    writable: true,
    q: {
        b: {
            d: {
                w: {
                    r: {
                        f: 30,
                        a: 40
                    }
                }
            }
        }
    }
}
</code></pre></div><p>类似的规则
<br> <img src="https://user-gold-cdn.xitu.io/2018/12/29/167f7887435c784e?imageView2/2/w/480/h/480/q/85/interlace/1" alt="悲伤蛙"></p> <h2 id="什么是递归"><a href="#什么是递归" aria-hidden="true" class="header-anchor">#</a> 什么是递归</h2> <p>来自百度的解释：
<br> <strong>递归：<a href="https://baike.baidu.com/item/%E9%80%92%E5%BD%92/1740695" target="_blank" rel="noopener noreferrer">程序调用自身的编程技巧称为递归 (recursion)<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></strong> <br> <strong>尾递归：<a href="https://baike.baidu.com/item/%E5%B0%BE%E9%80%92%E5%BD%92/554682" target="_blank" rel="noopener noreferrer">如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></strong></p> <p>就是 <strong>复读机</strong> <img src="https://user-gold-cdn.xitu.io/2018/12/29/167f799c0168cbb1?w=638&h=580&f=jpeg&s=38467" alt="复读机"></p> <h2 id="递归怎么写？"><a href="#递归怎么写？" aria-hidden="true" class="header-anchor">#</a> 递归怎么写？</h2> <p><strong>一般</strong></p> <div class="language- extra-class"><pre class="language-text"><code>const fibonacci = num =&gt; (num === 1 ? 1 : num * fibonacci(num - 1))
</code></pre></div><p><strong>尾递归</strong></p> <div class="language- extra-class"><pre class="language-text"><code>const fibonacci = (num, total = 1) =&gt; (num === 0 ? total : fibonacci(num - 1, num * total))
</code></pre></div><p><strong>Array.reduce</strong></p> <div class="language- extra-class"><pre class="language-text"><code>const getArray = count =&gt; Array.from({ length: count }, (value, key) =&gt; key)
const fibonacci = num =&gt; getArray(num).reduceRight((accumulator, currentValue) =&gt; accumulator * currentValue)
</code></pre></div><h2 id="功能实现"><a href="#功能实现" aria-hidden="true" class="header-anchor">#</a> 功能实现</h2> <h3 id="分步实现"><a href="#分步实现" aria-hidden="true" class="header-anchor">#</a> 分步实现</h3> <ol><li>过滤常规内容，获取特殊的备注信息，去除空格，并且转成数组
<ul><li>此时的数组内容为<div class="language- extra-class"><pre class="language-text"><code>[
    '//% blockId=&quot;sloth_servo_write&quot;  block=&quot;set servo %channel|degree %degree&quot;',
    '//% advanced=true',
    '//% weight=50',
    '//% degree.min=0 degree.max=180',
    '//% channel.fieldEditor=&quot;gridpicker&quot; channel.fieldOptions.columns=4',
    '//% a.b.c.d=20 a.b.c.e=222',
    '//% q.b.d.w.r.f=30 q.b.d.w.r.a=40'
]
</code></pre></div></li></ul> <div class="language- extra-class"><pre class="language-text"><code>const code = `
//% width=&quot;100px&quot; height=&quot;200px&quot;
//% pos.top=&quot;50px&quot; pos.left=&quot;50px&quot;
//% writable=true
//% q.b.d.w.r.f=30 q.b.d.w.r.a=40`
// 获取特殊注释数组
const annotation_array_filter = annotation_item =&gt; annotation_item.indexOf('//%') &gt;= 0;
// 去除特殊注释前后的空格
const annotation_array_remove_space = annotation_item =&gt; annotation_item.trim();
const annotation_array = code.split('\n')
                             .filter(annotation_array_filter)
                             .map(annotation_array_remove_space)
</code></pre></div></li> <li>遍历特殊规则数组，把每一项配置都压入一个新对象
<ul><li>此时的新对象内内容为<div class="language- extra-class"><pre class="language-text"><code>{
    a.b.c.d: 20,
    a.b.c.e: 222,
    advanced: true,
    block: &quot;set servo %channel|degree %degree&quot;,
    blockId: &quot;sloth_servo_write&quot;,
    channel.fieldEditor: &quot;gridpicker&quot;,
    channel.fieldOptions.columns: 4,
    degree.max: 180,
    degree.min: 0,
    q.b.d.w.r.a: 40,
    q.b.d.w.r.f: 30,
    weight: 50,
}
</code></pre></div></li></ul></li></ol> <div class="language- extra-class"><pre class="language-text"><code>      const annotation_array_loop = annotation_item =&gt; {
        // 把注释中的每一项配置转成对象
        const result_forEach = result_item =&gt; {
          let annotation_sub_object = {};
          // 如果特殊注释数组中的每一项包含多个配置，则扁平化
          const array_flattened = data =&gt; {
            const is_array = (this.type(data) === '[object Array]');
            const object_recursion = () =&gt; {
              const [key, value] = data.split('=');
              const annotation_sub_object = {};
              try {
                annotation_sub_object[key] = JSON.parse(value);
              } catch (error) {
                annotation_sub_object[key] = JSON.parse(value + '&quot;')
              };
              annotation_object = {
                ...annotation_object,
                ...annotation_sub_object
              };
            };
            // 判断注释数组项中每一个元素是否有多个配置，如果有则递归，否则则注入对象
            is_array ? data.forEach(e =&gt; { array_flattened(e); }) : object_recursion();
          };
          array_flattened(result_item);
        };
        // 去除特殊数组中每一项多余的内容
        const result_map = result_item =&gt; (result_item.match(/\=/g).length &gt; 1 ? result_item.split(' ') : result_item);
        const result = annotation_item.replace('//% ', '')
                                      .split('/\&quot; /g')
                                      .map(result_map);
        result_forEach(result);
      };
      let annotation_object = {}; // 承载每一个配置的对象
      annotation_array.forEach(annotation_array_loop);
</code></pre></div><ol start="3"><li>把数组里的元素转成对象
<ul><li>此时数组内容为<div class="language- extra-class"><pre class="language-text"><code>[
    {
        blockId: &quot;sloth_servo_write&quot;
    },
    {
        advanced: true
    },
    ...
]
</code></pre></div></li></ul></li></ol> <div class="language- extra-class"><pre class="language-text"><code>      let main_array = []; // 承载每一个配置的数组
      const annotation_object_keys = Object.keys(annotation_object); // 获取扁平化后的注释对象的key
      const annotation_object_keys_loop = annotation_object_key =&gt; { // 循环变量每一项注释
        const annotation_object_key_array = annotation_object_key.split('.'); // 把多级对象转成数组
        const annotation_object_value = annotation_object[annotation_object_key]; // 获取每一项元素的值
        let sub_object = {}; // 暂时承载配置对象的对象
        const key_reduce = (accumulator, current_value, current_index, array) =&gt; { // key值递归，对每一项配置进行合并
          if (current_index === 0) { // 如果当前遍历的元素为第一项，也就是说为配置的顶级对象，所以直接压入对象，并且输出
            sub_object[current_value] = (current_index === array.length - 1 ? annotation_object_value : {});
            return sub_object[current_value];
          }
          accumulator[current_value] = {}; // 如果当前遍历的元素不为第一项，则当前对象元素变为对象
          if (current_index === array.length - 1) { // 如果当前遍历的元素为数组最后一项，说明是配置对象最底的元素，可以直接赋值
            accumulator[current_value] = annotation_object_value;
          }
          return accumulator[current_value];
        };
        let level_object = annotation_object_key_array.reduce(key_reduce, annotation_object_key_array[0]);
        level_object = undefined; // 清空level_object
        main_array.push(sub_object);
        sub_object = undefined; // 清空sub_object
      }
      annotation_object_keys.forEach(annotation_object_keys_loop);
</code></pre></div><ol start="4"><li>递归合并对象
<ul><li>此时的对象为<div class="language- extra-class"><pre class="language-text"><code>{
    a: {b: {…}},
    advanced: true,
    block: &quot;set servo %channel|degree %degree&quot;,
    blockId: &quot;sloth_servo_write&quot;,
    channel: {fieldEditor: &quot;gridpicker&quot;, fieldOptions: {…}},
    degree: {min: 0, max: 180},
    q: {b: {…}},
    weight: 50
}
</code></pre></div></li></ul></li></ol> <div class="language- extra-class"><pre class="language-text"><code>      const annotation_tree = {};
      const tree_data = (key, value, object) =&gt; { // 递归合并对象
        if (this.type(value) !== '[object Object]') { // 如果当前传入元素为对象，则直接压入对象中
          object[key] = value;
        } else { // 否则继续递归
          if (!object[key]) {
            object[key] = {};
          };
          for (let item in value) {
            tree_data(item, value[item], object[key]);
          }
        };
      };
      const main_array_forEach = item =&gt; { // 循环遍历配置数组
        const key = Object.keys(item)[0];
        const value = Object.values(item)[0];
        tree_data(key, value, annotation_tree);
      };
      main_array.forEach(main_array_forEach);
      main_array = undefined; // 清空main_array
</code></pre></div><h3 id="完整代码"><a href="#完整代码" aria-hidden="true" class="header-anchor">#</a> 完整代码</h3> <div class="language- extra-class"><pre class="language-text"><code>// 代码转换器
((wid, dcm) =&gt; {
  'use strict';
  const win = wid;
  const doc = dcm;

  // 基础信息
  const base_info = {
    'version': '0.0.1',
    'author': 'kris',
  };

  // 输出的函数
  const funcs = {
    annotation_parser (annotation) {
      // 配置树初始化
      this.annotation_tree = {};
      // 获取特殊注释数组
      const annotation_array_filter = annotation_item =&gt; annotation_item.indexOf('//%') &gt;= 0;
      // 去除特殊注释前后的空格
      const annotation_array_remove_space = annotation_item =&gt; annotation_item.trim();
      // 循环遍历特殊注释数组
      const annotation_array_loop = annotation_item =&gt; {
        // 把注释中的每一项配置转成对象
        const result_forEach = result_item =&gt; {
          let annotation_sub_object = {};
          // 如果特殊注释数组中的每一项包含多个配置，则扁平化
          const array_flattened = data =&gt; {
            const is_array = (this.type(data) === '[object Array]');
            const object_recursion = () =&gt; {
              const [key, value] = data.split('=');
              const annotation_sub_object = {};
              try {
                annotation_sub_object[key] = JSON.parse(value);
              } catch (error) {
                annotation_sub_object[key] = JSON.parse(value + '&quot;')
              };
              annotation_object = {
                ...annotation_object,
                ...annotation_sub_object
              };
            };
            // 判断注释数组项中每一个元素是否有多个配置，如果有则递归，否则则注入对象
            is_array ? data.forEach(e =&gt; { array_flattened(e); }) : object_recursion();
          };
          array_flattened(result_item);
        };
        // 去除特殊数组中每一项多余的内容
        const result_map = result_item =&gt; (result_item.match(/\=/g).length &gt; 1 ? result_item.split(' ') : result_item);
        const result = annotation_item.replace('//% ', '')
                                      .split('/\&quot; /g')
                                      .map(result_map);
        result_forEach(result);
      };
      let annotation_object = {}; // 承载每一个配置的对象
      annotation.filter(annotation_array_filter)
                .map(annotation_array_remove_space)
                .forEach(annotation_array_loop);
      let main_array = []; // 承载每一个配置的数组
      const annotation_object_keys = Object.keys(annotation_object); // 获取扁平化后的注释对象的key
      const annotation_object_keys_loop = annotation_object_key =&gt; { // 循环变量每一项注释
        const annotation_object_key_array = annotation_object_key.split('.'); // 把多级对象转成数组
        const annotation_object_value = annotation_object[annotation_object_key]; // 获取每一项元素的值
        let sub_object = {}; // 暂时承载配置对象的对象
        const key_reduce = (accumulator, current_value, current_index, array) =&gt; { // key值递归，对每一项配置进行合并
          if (current_index === 0) { // 如果当前遍历的元素为第一项，也就是说为配置的顶级对象，所以直接压入对象，并且输出
            sub_object[current_value] = (current_index === array.length - 1 ? annotation_object_value : {});
            return sub_object[current_value];
          }
          accumulator[current_value] = {}; // 如果当前遍历的元素不为第一项，则当前对象元素变为对象
          if (current_index === array.length - 1) { // 如果当前遍历的元素为数组最后一项，说明是配置对象最底的元素，可以直接赋值
            accumulator[current_value] = annotation_object_value;
          }
          return accumulator[current_value];
        };
        let level_object = annotation_object_key_array.reduce(key_reduce, annotation_object_key_array[0]);
        level_object = undefined; // 清空level_object
        main_array.push(sub_object);
        sub_object = undefined; // 清空sub_object
      }
      annotation_object_keys.forEach(annotation_object_keys_loop);
      const tree_data = (key, value, object) =&gt; { // 递归合并对象
        if (this.type(value) !== '[object Object]') { // 如果当前传入元素为对象，则直接压入对象中
          object[key] = value;
        } else { // 否则继续递归
          if (!object[key]) {
            object[key] = {};
          };
          for (let item in value) {
            tree_data(item, value[item], object[key]);
          }
        };
      };
      const main_array_forEach = item =&gt; { // 循环遍历配置数组
        const key = Object.keys(item)[0];
        const value = Object.values(item)[0];
        tree_data(key, value, this.annotation_tree);
      };
      main_array.forEach(main_array_forEach);
      main_array = undefined; // 清空main_array
    },
  };
  // 引用的资源
  const libs = {};
  // 工具函数
  const tools = {
    // 获取元素类型
    type (object) {
      return Object.prototype.toString.call(object);
    },
    // 分离传入的代码跟配置
    separate_code_and_config (data) {
      data.split('\n')
          .forEach(item =&gt; {
        item.indexOf('//%') &gt;= 0 ? this.blockly_config_array.push(item.trim()) : this.python_code_array.push(item);
      });
    },
  };
  // 定义的元素
  const vars = {
    blockly_config_array: [],
    python_code_array: [],
    annotation_tree: {},
    python_tree: {},
  };
  // 根对象
  const code_transformer = {
    ...base_info,
    ...libs,
    ...funcs,
    ...tools,
    ...vars,
  };

  const _global = (() =&gt; {
    return this || (0, eval)('this');
  })();
  if (typeof module !== 'undefined' &amp;&amp; module.exports) {
    module.exports = code_transformer;
  } else if (typeof define === 'function' &amp;&amp; define.amd) {
    define([], function () {
      return code_transformer;
    });
  } else {
    !('code_transformer' in _global) &amp;&amp; (_global.code_transformer = code_transformer);
  };
})(window, document);

</code></pre></div><h3 id="备注：函数体积好大呀，但这只是业务里的一个小小小功能，流下了不会优化代码的泪水"><a href="#备注：函数体积好大呀，但这只是业务里的一个小小小功能，流下了不会优化代码的泪水" aria-hidden="true" class="header-anchor">#</a> 备注：函数体积好大呀，但这只是业务里的一个小小小功能，流下了不会优化代码的泪水~</h3> <p><img src="https://user-gold-cdn.xitu.io/2018/12/29/167f7d4020b4dd4e?w=255&h=255&f=jpeg&s=18243" alt="哭"></p> <p>如果你喜欢探讨技术，或者对本文有任何的意见或建议，非常欢迎加鱼头微信好友一起探讨，当然，鱼头也非常希望能跟你一起聊生活，聊爱好，谈天说地。 鱼头的微信号是：krisChans95 也可以扫码添加好友，备注“博客”就行</p> <p><img src="https://fish-pond-1253945200.cos.ap-guangzhou.myqcloud.com/img/base/wx-qrcode1.jpg" alt="wx-qrcode"></p></div> <div class="page-footer content">
    网站备案号：粤ICP备17113436号-1
  </div> <!----> <div class="right-group"><div class="item"><span class="title">加入前端鱼塘</span> <span class="desc">
        扫描二维码回复
        <span class="inner">加群</span> 学习
      </span> <img width="100%" src="https://fish-pond-1253945200.cos.ap-guangzhou.myqcloud.com/img/base/wx-qrcode.jpg"></div></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <div></div></div></div>
    <script src="/assets/js/33.537cee41.js" defer></script><script src="/assets/js/app.2b0bb46a.js" defer></script>
    <!-- Hotjar Tracking Code for yuchengkai.cn -->
    <script>
      var _hmt = _hmt || []
      ;(function() {
        var hm = document.createElement('script')
        hm.src = 'https://hm.baidu.com/hm.js?52ee35894430604d0d3ce3b9c089adf9'
        var s = document.getElementsByTagName('script')[0]
        s.parentNode.insertBefore(hm, s)
      })()
    </script>
  </body>
</html>

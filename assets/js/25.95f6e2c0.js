(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{164:function(t,n,e){"use strict";e.r(n);var a=e(0),r=Object(a.a)({},function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{staticClass:"content"},[t._m(0),e("blockquote",[e("ul",[e("li",[t._v("作者：陈大鱼头")]),e("li",[t._v("github： "),e("a",{attrs:{href:"https://github.com/KRISACHAN",target:"_blank",rel:"noopener noreferrer"}},[t._v("KRISACHAN"),e("OutboundLink")],1)])])]),t._m(1),t._m(2),t._m(3),e("p",[t._v("要转成")]),t._m(4),t._m(5),t._m(6),e("p",[t._v("来自百度的解释：\n"),e("br"),e("strong",[t._v("递归："),e("a",{attrs:{href:"https://baike.baidu.com/item/%E9%80%92%E5%BD%92/1740695",target:"_blank",rel:"noopener noreferrer"}},[t._v("程序调用自身的编程技巧称为递归 (recursion)"),e("OutboundLink")],1)]),e("br"),e("strong",[t._v("尾递归："),e("a",{attrs:{href:"https://baike.baidu.com/item/%E5%B0%BE%E9%80%92%E5%BD%92/554682",target:"_blank",rel:"noopener noreferrer"}},[t._v("如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。"),e("OutboundLink")],1)])]),t._m(7),t._m(8),t._m(9),t._m(10),t._m(11),t._m(12),t._m(13),t._m(14),t._m(15),t._m(16),t._m(17),t._m(18),t._m(19),t._m(20),t._m(21),t._m(22),t._m(23),t._m(24),t._m(25),t._m(26)])},[function(){var t=this.$createElement,n=this._self._c||t;return n("h1",{attrs:{id:"记一次递归在我项目中所发挥的作用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#记一次递归在我项目中所发挥的作用","aria-hidden":"true"}},[this._v("#")]),this._v(" 记一次递归在我项目中所发挥的作用")])},function(){var t=this.$createElement,n=this._self._c||t;return n("h2",{attrs:{id:"背景"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#背景","aria-hidden":"true"}},[this._v("#")]),this._v(" 背景")])},function(){var t=this.$createElement,n=this._self._c||t;return n("p",[this._v("在最近的项目中，有这么一个功能点，就是要获取在WEB IDE里用户所写的注释中的一段特殊规则，然后解析成一段JS config 对象\n"),n("br"),this._v("\n例如：\n"),n("br")])},function(){var t=this.$createElement,n=this._self._c||t;return n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v('//% width="100px" height="200px"\n//% pos.top="50px" pos.left="50px"\n//% writable=true\n//% q.b.d.w.r.f=30 q.b.d.w.r.a=40\n')])])])},function(){var t=this.$createElement,n=this._self._c||t;return n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("{\n    width: '100px',\n    height: '200px',\n    pos: {\n        top: '50px',\n        left: '50px'\n    },\n    writable: true,\n    q: {\n        b: {\n            d: {\n                w: {\n                    r: {\n                        f: 30,\n                        a: 40\n                    }\n                }\n            }\n        }\n    }\n}\n")])])])},function(){var t=this.$createElement,n=this._self._c||t;return n("p",[this._v("类似的规则\n"),n("br"),n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/12/29/167f7887435c784e?imageView2/2/w/480/h/480/q/85/interlace/1",alt:"悲伤蛙"}})])},function(){var t=this.$createElement,n=this._self._c||t;return n("h2",{attrs:{id:"什么是递归"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是递归","aria-hidden":"true"}},[this._v("#")]),this._v(" 什么是递归")])},function(){var t=this.$createElement,n=this._self._c||t;return n("p",[this._v("就是 "),n("strong",[this._v("复读机")]),n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/12/29/167f799c0168cbb1?w=638&h=580&f=jpeg&s=38467",alt:"复读机"}})])},function(){var t=this.$createElement,n=this._self._c||t;return n("h2",{attrs:{id:"递归怎么写？"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#递归怎么写？","aria-hidden":"true"}},[this._v("#")]),this._v(" 递归怎么写？")])},function(){var t=this.$createElement,n=this._self._c||t;return n("p",[n("strong",[this._v("一般")])])},function(){var t=this.$createElement,n=this._self._c||t;return n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("const fibonacci = num => (num === 1 ? 1 : num * fibonacci(num - 1))\n")])])])},function(){var t=this.$createElement,n=this._self._c||t;return n("p",[n("strong",[this._v("尾递归")])])},function(){var t=this.$createElement,n=this._self._c||t;return n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("const fibonacci = (num, total = 1) => (num === 0 ? total : fibonacci(num - 1, num * total))\n")])])])},function(){var t=this.$createElement,n=this._self._c||t;return n("p",[n("strong",[this._v("Array.reduce")])])},function(){var t=this.$createElement,n=this._self._c||t;return n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("const getArray = count => Array.from({ length: count }, (value, key) => key)\nconst fibonacci = num => getArray(num).reduceRight((accumulator, currentValue) => accumulator * currentValue)\n")])])])},function(){var t=this.$createElement,n=this._self._c||t;return n("h2",{attrs:{id:"功能实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#功能实现","aria-hidden":"true"}},[this._v("#")]),this._v(" 功能实现")])},function(){var t=this.$createElement,n=this._self._c||t;return n("h3",{attrs:{id:"分步实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#分步实现","aria-hidden":"true"}},[this._v("#")]),this._v(" 分步实现")])},function(){var t=this.$createElement,n=this._self._c||t;return n("ol",[n("li",[this._v("过滤常规内容，获取特殊的备注信息，去除空格，并且转成数组\n"),n("ul",[n("li",[this._v("此时的数组内容为"),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("[\n    '//% blockId=\"sloth_servo_write\"  block=\"set servo %channel|degree %degree\"',\n    '//% advanced=true',\n    '//% weight=50',\n    '//% degree.min=0 degree.max=180',\n    '//% channel.fieldEditor=\"gridpicker\" channel.fieldOptions.columns=4',\n    '//% a.b.c.d=20 a.b.c.e=222',\n    '//% q.b.d.w.r.f=30 q.b.d.w.r.a=40'\n]\n")])])])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v('const code = `\n//% width="100px" height="200px"\n//% pos.top="50px" pos.left="50px"\n//% writable=true\n//% q.b.d.w.r.f=30 q.b.d.w.r.a=40`\n// 获取特殊注释数组\nconst annotation_array_filter = annotation_item => annotation_item.indexOf(\'//%\') >= 0;\n// 去除特殊注释前后的空格\nconst annotation_array_remove_space = annotation_item => annotation_item.trim();\nconst annotation_array = code.split(\'\\n\')\n                             .filter(annotation_array_filter)\n                             .map(annotation_array_remove_space)\n')])])])]),n("li",[this._v("遍历特殊规则数组，把每一项配置都压入一个新对象\n"),n("ul",[n("li",[this._v("此时的新对象内内容为"),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v('{\n    a.b.c.d: 20,\n    a.b.c.e: 222,\n    advanced: true,\n    block: "set servo %channel|degree %degree",\n    blockId: "sloth_servo_write",\n    channel.fieldEditor: "gridpicker",\n    channel.fieldOptions.columns: 4,\n    degree.max: 180,\n    degree.min: 0,\n    q.b.d.w.r.a: 40,\n    q.b.d.w.r.f: 30,\n    weight: 50,\n}\n')])])])])])])])},function(){var t=this.$createElement,n=this._self._c||t;return n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("      const annotation_array_loop = annotation_item => {\n        // 把注释中的每一项配置转成对象\n        const result_forEach = result_item => {\n          let annotation_sub_object = {};\n          // 如果特殊注释数组中的每一项包含多个配置，则扁平化\n          const array_flattened = data => {\n            const is_array = (this.type(data) === '[object Array]');\n            const object_recursion = () => {\n              const [key, value] = data.split('=');\n              const annotation_sub_object = {};\n              try {\n                annotation_sub_object[key] = JSON.parse(value);\n              } catch (error) {\n                annotation_sub_object[key] = JSON.parse(value + '\"')\n              };\n              annotation_object = {\n                ...annotation_object,\n                ...annotation_sub_object\n              };\n            };\n            // 判断注释数组项中每一个元素是否有多个配置，如果有则递归，否则则注入对象\n            is_array ? data.forEach(e => { array_flattened(e); }) : object_recursion();\n          };\n          array_flattened(result_item);\n        };\n        // 去除特殊数组中每一项多余的内容\n        const result_map = result_item => (result_item.match(/\\=/g).length > 1 ? result_item.split(' ') : result_item);\n        const result = annotation_item.replace('//% ', '')\n                                      .split('/\\\" /g')\n                                      .map(result_map);\n        result_forEach(result);\n      };\n      let annotation_object = {}; // 承载每一个配置的对象\n      annotation_array.forEach(annotation_array_loop);\n")])])])},function(){var t=this.$createElement,n=this._self._c||t;return n("ol",{attrs:{start:"3"}},[n("li",[this._v("把数组里的元素转成对象\n"),n("ul",[n("li",[this._v("此时数组内容为"),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v('[\n    {\n        blockId: "sloth_servo_write"\n    },\n    {\n        advanced: true\n    },\n    ...\n]\n')])])])])])])])},function(){var t=this.$createElement,n=this._self._c||t;return n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("      let main_array = []; // 承载每一个配置的数组\n      const annotation_object_keys = Object.keys(annotation_object); // 获取扁平化后的注释对象的key\n      const annotation_object_keys_loop = annotation_object_key => { // 循环变量每一项注释\n        const annotation_object_key_array = annotation_object_key.split('.'); // 把多级对象转成数组\n        const annotation_object_value = annotation_object[annotation_object_key]; // 获取每一项元素的值\n        let sub_object = {}; // 暂时承载配置对象的对象\n        const key_reduce = (accumulator, current_value, current_index, array) => { // key值递归，对每一项配置进行合并\n          if (current_index === 0) { // 如果当前遍历的元素为第一项，也就是说为配置的顶级对象，所以直接压入对象，并且输出\n            sub_object[current_value] = (current_index === array.length - 1 ? annotation_object_value : {});\n            return sub_object[current_value];\n          }\n          accumulator[current_value] = {}; // 如果当前遍历的元素不为第一项，则当前对象元素变为对象\n          if (current_index === array.length - 1) { // 如果当前遍历的元素为数组最后一项，说明是配置对象最底的元素，可以直接赋值\n            accumulator[current_value] = annotation_object_value;\n          }\n          return accumulator[current_value];\n        };\n        let level_object = annotation_object_key_array.reduce(key_reduce, annotation_object_key_array[0]);\n        level_object = undefined; // 清空level_object\n        main_array.push(sub_object);\n        sub_object = undefined; // 清空sub_object\n      }\n      annotation_object_keys.forEach(annotation_object_keys_loop);\n")])])])},function(){var t=this.$createElement,n=this._self._c||t;return n("ol",{attrs:{start:"4"}},[n("li",[this._v("递归合并对象\n"),n("ul",[n("li",[this._v("此时的对象为"),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v('{\n    a: {b: {…}},\n    advanced: true,\n    block: "set servo %channel|degree %degree",\n    blockId: "sloth_servo_write",\n    channel: {fieldEditor: "gridpicker", fieldOptions: {…}},\n    degree: {min: 0, max: 180},\n    q: {b: {…}},\n    weight: 50\n}\n')])])])])])])])},function(){var t=this.$createElement,n=this._self._c||t;return n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("      const annotation_tree = {};\n      const tree_data = (key, value, object) => { // 递归合并对象\n        if (this.type(value) !== '[object Object]') { // 如果当前传入元素为对象，则直接压入对象中\n          object[key] = value;\n        } else { // 否则继续递归\n          if (!object[key]) {\n            object[key] = {};\n          };\n          for (let item in value) {\n            tree_data(item, value[item], object[key]);\n          }\n        };\n      };\n      const main_array_forEach = item => { // 循环遍历配置数组\n        const key = Object.keys(item)[0];\n        const value = Object.values(item)[0];\n        tree_data(key, value, annotation_tree);\n      };\n      main_array.forEach(main_array_forEach);\n      main_array = undefined; // 清空main_array\n")])])])},function(){var t=this.$createElement,n=this._self._c||t;return n("h3",{attrs:{id:"完整代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#完整代码","aria-hidden":"true"}},[this._v("#")]),this._v(" 完整代码")])},function(){var t=this.$createElement,n=this._self._c||t;return n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("// 代码转换器\n((wid, dcm) => {\n  'use strict';\n  const win = wid;\n  const doc = dcm;\n\n  // 基础信息\n  const base_info = {\n    'version': '0.0.1',\n    'author': 'kris',\n  };\n\n  // 输出的函数\n  const funcs = {\n    annotation_parser (annotation) {\n      // 配置树初始化\n      this.annotation_tree = {};\n      // 获取特殊注释数组\n      const annotation_array_filter = annotation_item => annotation_item.indexOf('//%') >= 0;\n      // 去除特殊注释前后的空格\n      const annotation_array_remove_space = annotation_item => annotation_item.trim();\n      // 循环遍历特殊注释数组\n      const annotation_array_loop = annotation_item => {\n        // 把注释中的每一项配置转成对象\n        const result_forEach = result_item => {\n          let annotation_sub_object = {};\n          // 如果特殊注释数组中的每一项包含多个配置，则扁平化\n          const array_flattened = data => {\n            const is_array = (this.type(data) === '[object Array]');\n            const object_recursion = () => {\n              const [key, value] = data.split('=');\n              const annotation_sub_object = {};\n              try {\n                annotation_sub_object[key] = JSON.parse(value);\n              } catch (error) {\n                annotation_sub_object[key] = JSON.parse(value + '\"')\n              };\n              annotation_object = {\n                ...annotation_object,\n                ...annotation_sub_object\n              };\n            };\n            // 判断注释数组项中每一个元素是否有多个配置，如果有则递归，否则则注入对象\n            is_array ? data.forEach(e => { array_flattened(e); }) : object_recursion();\n          };\n          array_flattened(result_item);\n        };\n        // 去除特殊数组中每一项多余的内容\n        const result_map = result_item => (result_item.match(/\\=/g).length > 1 ? result_item.split(' ') : result_item);\n        const result = annotation_item.replace('//% ', '')\n                                      .split('/\\\" /g')\n                                      .map(result_map);\n        result_forEach(result);\n      };\n      let annotation_object = {}; // 承载每一个配置的对象\n      annotation.filter(annotation_array_filter)\n                .map(annotation_array_remove_space)\n                .forEach(annotation_array_loop);\n      let main_array = []; // 承载每一个配置的数组\n      const annotation_object_keys = Object.keys(annotation_object); // 获取扁平化后的注释对象的key\n      const annotation_object_keys_loop = annotation_object_key => { // 循环变量每一项注释\n        const annotation_object_key_array = annotation_object_key.split('.'); // 把多级对象转成数组\n        const annotation_object_value = annotation_object[annotation_object_key]; // 获取每一项元素的值\n        let sub_object = {}; // 暂时承载配置对象的对象\n        const key_reduce = (accumulator, current_value, current_index, array) => { // key值递归，对每一项配置进行合并\n          if (current_index === 0) { // 如果当前遍历的元素为第一项，也就是说为配置的顶级对象，所以直接压入对象，并且输出\n            sub_object[current_value] = (current_index === array.length - 1 ? annotation_object_value : {});\n            return sub_object[current_value];\n          }\n          accumulator[current_value] = {}; // 如果当前遍历的元素不为第一项，则当前对象元素变为对象\n          if (current_index === array.length - 1) { // 如果当前遍历的元素为数组最后一项，说明是配置对象最底的元素，可以直接赋值\n            accumulator[current_value] = annotation_object_value;\n          }\n          return accumulator[current_value];\n        };\n        let level_object = annotation_object_key_array.reduce(key_reduce, annotation_object_key_array[0]);\n        level_object = undefined; // 清空level_object\n        main_array.push(sub_object);\n        sub_object = undefined; // 清空sub_object\n      }\n      annotation_object_keys.forEach(annotation_object_keys_loop);\n      const tree_data = (key, value, object) => { // 递归合并对象\n        if (this.type(value) !== '[object Object]') { // 如果当前传入元素为对象，则直接压入对象中\n          object[key] = value;\n        } else { // 否则继续递归\n          if (!object[key]) {\n            object[key] = {};\n          };\n          for (let item in value) {\n            tree_data(item, value[item], object[key]);\n          }\n        };\n      };\n      const main_array_forEach = item => { // 循环遍历配置数组\n        const key = Object.keys(item)[0];\n        const value = Object.values(item)[0];\n        tree_data(key, value, this.annotation_tree);\n      };\n      main_array.forEach(main_array_forEach);\n      main_array = undefined; // 清空main_array\n    },\n  };\n  // 引用的资源\n  const libs = {};\n  // 工具函数\n  const tools = {\n    // 获取元素类型\n    type (object) {\n      return Object.prototype.toString.call(object);\n    },\n    // 分离传入的代码跟配置\n    separate_code_and_config (data) {\n      data.split('\\n')\n          .forEach(item => {\n        item.indexOf('//%') >= 0 ? this.blockly_config_array.push(item.trim()) : this.python_code_array.push(item);\n      });\n    },\n  };\n  // 定义的元素\n  const vars = {\n    blockly_config_array: [],\n    python_code_array: [],\n    annotation_tree: {},\n    python_tree: {},\n  };\n  // 根对象\n  const code_transformer = {\n    ...base_info,\n    ...libs,\n    ...funcs,\n    ...tools,\n    ...vars,\n  };\n\n  const _global = (() => {\n    return this || (0, eval)('this');\n  })();\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = code_transformer;\n  } else if (typeof define === 'function' && define.amd) {\n    define([], function () {\n      return code_transformer;\n    });\n  } else {\n    !('code_transformer' in _global) && (_global.code_transformer = code_transformer);\n  };\n})(window, document);\n\n")])])])},function(){var t=this.$createElement,n=this._self._c||t;return n("h3",{attrs:{id:"备注：函数体积好大呀，但这只是业务里的一个小小小功能，流下了不会优化代码的泪水"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#备注：函数体积好大呀，但这只是业务里的一个小小小功能，流下了不会优化代码的泪水","aria-hidden":"true"}},[this._v("#")]),this._v(" 备注：函数体积好大呀，但这只是业务里的一个小小小功能，流下了不会优化代码的泪水~")])},function(){var t=this.$createElement,n=this._self._c||t;return n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/12/29/167f7d4020b4dd4e?w=255&h=255&f=jpeg&s=18243",alt:"哭"}})])}],!1,null,null,null);r.options.__file="recursion.md";n.default=r.exports}}]);
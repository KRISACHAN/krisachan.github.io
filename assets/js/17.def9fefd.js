(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{154:function(t,e,r){"use strict";r.r(e);var s=r(0),n=Object(s.a)({},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",{staticClass:"content"},[t._m(0),r("blockquote",[r("ul",[r("li",[t._v("作者：陈大鱼头")]),r("li",[t._v("github： "),r("a",{attrs:{href:"https://github.com/KRISACHAN",target:"_blank",rel:"noopener noreferrer"}},[t._v("KRISACHAN"),r("OutboundLink")],1)]),r("li",[t._v("记录原因：2019年3月30日在深圳举行了第五届的CSS Conf，鱼头作为一枚CSS新手以及爱好者也报名参加了。如果想知道鱼头参加完之后的感受，可以看知乎问题“参加2019年03月30日深圳第五届CSSConf是如何体验？”的"),r("a",{attrs:{href:"https://www.zhihu.com/question/318056547/answer/636926759",target:"_blank",rel:"noopener noreferrer"}},[t._v("回答"),r("OutboundLink")],1),t._v("。会上分享学习了许多干货知识，因为怕自己遗忘，遂写文章，以便后续记忆。")])])]),t._m(1),r("blockquote",[r("p",[t._v("《新时代CSS布局》的分享者是新加坡的国际知名CSS专家"),r("strong",[t._v("陈慧晶")]),t._v("。陈慧晶老师的个人博客地址是："),r("a",{attrs:{href:"https://www.chenhuijing.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.chenhuijing.com/"),r("OutboundLink")],1),t._v("。")])]),r("p",[t._v("陈慧晶老师的分享主题介绍如下：")]),t._m(2),r("p",[t._v("本次分享的在线Slide: "),r("a",{attrs:{href:"https://www.chenhuijing.com/slides/53-cssconfcn-2019/",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.chenhuijing.com/slides/53-cssconfcn-2019/"),r("OutboundLink")],1)]),t._m(3),t._m(4),r("p",[t._v("其实答案也很简单，就是因为在最初的时候，"),r("strong",[t._v("HTML")]),t._v("跟"),r("strong",[t._v("CSS")]),t._v("只是为了欧美国家而服务，而欧美国家文字排版又是横向的，所以最开始的设计也是也横向的文档流为主，到后面互联网不断发展，连接至全世界的时候，才有了纵向排版的需求，所以结论就是设计者一开始并没有考虑纵向排版，所以后续有需求的时候才会出现"),r("strong",[t._v("纵向比横向难排")]),t._v("的问题，关于纵横布局的比较可以查阅鱼头的"),r("strong",[t._v("Hello CSS")]),t._v("系列的"),r("a",{attrs:{href:"https://juejin.im/post/5c7eb0b951882546c20a872e",target:"_blank",rel:"noopener noreferrer"}},[t._v("CSS的逻辑属性与盒子模型"),r("OutboundLink")],1),t._v("。")]),r("p",[t._v("然后慧晶老师便分享了互联网的发展史。关于这部分内容，有兴趣的也可以查阅鱼头的"),r("strong",[t._v("Hello CSS")]),t._v("系列的"),r("router-link",{attrs:{to:"./../Hello_CSS/序章-起源.html"}},[t._v("序章-起源")]),t._v("。")],1),r("p",[t._v("在这里，慧晶老师分享了一个很有趣的链接，就是可以查看最初的网页长什么样，链接在此："),r("a",{attrs:{href:"https://worldwideweb.cern.ch/browser/",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://worldwideweb.cern.ch/browser/"),r("OutboundLink")],1),t._v("。")]),t._m(5),t._m(6),t._m(7),r("img",{attrs:{src:"https://www.chenhuijing.com/slides/53-cssconfcn-2019/img/new-layout.svg"}}),r("p",[t._v("CSS布局部队是由以下以及其他的553个属性组成。因为CSS是个团队项目。只有各属性相互协调配合，才能把CSS的威力完全发挥出来。")]),r("img",{attrs:{src:"https://www.chenhuijing.com/slides/53-cssconfcn-2019/img/team-layout.png"}}),t._m(8),t._m(9),t._m(10),r("img",{attrs:{src:t.$withBase("/img/css_conf_2019/css_render.png")}}),t._m(11),t._m(12),r("blockquote",[r("p",[t._v("慧晶老师又介绍了**"),r("a",{attrs:{href:"https://www.w3.org/TR/css-display-3/",target:"_blank",rel:"noopener noreferrer"}},[t._v("CSS显示模块（CSS Display Module Level 3）"),r("OutboundLink")],1),t._v("**，以下是原文摘抄。")])]),t._m(13),t._m(14),t._m(15),r("img",{attrs:{src:t.$withBase("/img/css_conf_2019/css_dml3.png")}}),t._m(16),r("blockquote",[r("p",[t._v("在这部分慧晶老师主要介绍了"),r("strong",[t._v("Flex")]),t._v("的语法以及使用技巧（关于语法部分，在此不再累述，有兴趣的可以翻阅"),r("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex",target:"_blank",rel:"noopener noreferrer"}},[t._v("MDN"),r("OutboundLink")],1),t._v("）。慧晶老师在介绍完"),r("strong",[t._v("Flex")]),t._v("之后便开始了第一个栗子："),r("strong",[t._v("自动margin是你的好友")])])]),r("img",{attrs:{src:t.$withBase("/img/css_conf_2019/flex_auto_margin.png")}}),r("p",[t._v("在上面这个简单的例子，容器内只有一个子元素。我们可以运用margin来操纵它。如果不设定任何方向，盒子就会在容器的正中间。一行搞定水平垂直居中的问题。")]),t._m(17),t._m(18),t._m(19),t._m(20),r("img",{attrs:{src:"https://www.chenhuijing.com/slides/53-cssconfcn-2019/img/parent-child.svg"}}),t._m(21),t._m(22),r("p",[t._v("在这里，慧晶老师解释道：")]),t._m(23),t._m(24),t._m(25),r("p",[r("strong",[t._v("鱼头注：这里具体的属性也不累述了，有兴趣的可以自行查阅[W3C][https://www.w3.org/TR/css-align-3/]或者"),r("a",{attrs:{href:"https://www.w3cplus.com/css/css-grids-flexbox-and-box-alignment-our-new-system-for-web-layout.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("W3C PLUS"),r("OutboundLink")],1)])]),t._m(26),t._m(27),r("p",[t._v("关于这个问题的答案，慧晶老师回答道：")]),t._m(28),t._m(29),t._m(30),r("img",{attrs:{src:t.$withBase("/img/css_conf_2019/flex_and_grid.png")}}),t._m(31),r("img",{attrs:{src:t.$withBase("/img/css_conf_2019/layout_fail_and_success.png")}}),t._m(32),t._m(33),t._m(34),r("img",{attrs:{src:t.$withBase("/img/css_conf_2019/content_base_sizing.png")}}),t._m(35),r("img",{attrs:{src:t.$withBase("/img/css_conf_2019/flexible_sizing.png")}}),r("p",[t._v("接下来慧晶老师主要是对以下三组属性进行了对比：")]),r("ol",[r("li",[r("p",[r("a",{attrs:{href:"https://www.chenhuijing.com/slides/53-cssconfcn-2019/#/37",target:"_blank",rel:"noopener noreferrer"}},[r("code",[t._v("fr")]),t._v("对比"),r("code",[t._v("auto")]),r("OutboundLink")],1)])]),r("li",[r("p",[r("a",{attrs:{href:"https://www.chenhuijing.com/slides/53-cssconfcn-2019/#/37",target:"_blank",rel:"noopener noreferrer"}},[r("code",[t._v("max-content")]),t._v("对比固定"),r("code",[t._v("width")]),r("OutboundLink")],1)])]),r("li",[r("p",[r("a",{attrs:{href:"https://www.chenhuijing.com/slides/53-cssconfcn-2019/#/39",target:"_blank",rel:"noopener noreferrer"}},[r("code",[t._v("fit-content")]),t._v("对比"),r("code",[t._v("minmax()")]),r("OutboundLink")],1)])])]),t._m(36),t._m(37),t._m(38),t._m(39),r("p",[r("strong",[t._v("（鱼头注：关于"),r("code",[t._v("@supports")]),t._v("的使用，有兴趣的可以查看鱼头的文章["),r("router-link",{attrs:{to:"./../Hello_CSS/第一章-CSS的语法与工作流.html"}},[t._v("第一章-CSS的语法与工作流")]),t._v("）")],1)]),r("br"),r("br"),t._v("\n如果你也喜欢`CSS`，喜欢探讨技术，或者对本文，本系列有任何的意见或建议，你可以扫描下方二维码，关注微信公众号“"),r("b",[t._v("鱼头的Web海洋")]),t._v("”，随时与鱼头互动。欢迎！衷心希望可以遇见你。\n"),r("br"),r("br"),r("img",{staticStyle:{margin:"24px auto",display:"block","font-size":"0","vertical-align":"middle",width:"100%"},attrs:{src:t.$withBase("/img/qrcode-base.png")}})])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"css-conf-《新时代css布局》学习总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#css-conf-《新时代css布局》学习总结","aria-hidden":"true"}},[this._v("#")]),this._v(" CSS Conf -《新时代CSS布局》学习总结")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"分享嘉宾简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分享嘉宾简介","aria-hidden":"true"}},[this._v("#")]),this._v(" 分享嘉宾简介")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("CSS布局经常是令前端开发者头痛的一块工作。但是近几年来，浏览器不断发展，开始支持弹性盒子、网格布局、盒模型对齐等布局功能。这些CSS标准纯粹是为了应付网络布局而编写的。我们将深入了解这些新属性的特征，新时代的布局技巧、例子及最佳实践。希望听众会有所启发，利用这些新的CSS属性创造更符合浏览器本质的设计。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"为什么纵向比横向难排？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么纵向比横向难排？","aria-hidden":"true"}},[this._v("#")]),this._v(" 为什么纵向比横向难排？")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("在分享的开始，慧晶老师便抛出了上述的问题。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"web布局系统"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#web布局系统","aria-hidden":"true"}},[this._v("#")]),this._v(" Web布局系统")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("在这一小节中，慧晶老师主要分享了"),e("strong",[this._v("Flexbox")]),this._v("、"),e("strong",[this._v("Grid")]),this._v("跟"),e("strong",[this._v("Box Alignment")]),this._v("这CSS新时代布局的三大栋梁。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"css布局部队"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#css布局部队","aria-hidden":"true"}},[this._v("#")]),this._v(" CSS布局部队")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"浏览器的渲染过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的渲染过程","aria-hidden":"true"}},[this._v("#")]),this._v(" 浏览器的渲染过程")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("慧晶老师又介绍了浏览器的渲染过程，以下是原文摘抄。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("如果要揭开CSS布局的神秘面纱，那就必须先熟悉浏览器的渲染过程。渲染引擎会把服务器发送过来的Source文档解析成浏览器能够明白的对象。而在渲染网页之前，浏览器会生成一个渲染树。这个渲染树是个中介性的结构（intermediary structure），是文档格式结构（formatting structure）的表示法。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("CSS在解析的过程，会计算出每个元素和文本节点的每个CSS属性值。浏览器就会靠其中的取值来判断要生成哪一类的盒子。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"css显示模块（css-display-module-level-3）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#css显示模块（css-display-module-level-3）","aria-hidden":"true"}},[this._v("#")]),this._v(" CSS显示模块（CSS Display Module Level 3）")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("CSS显示模块在这二十多年来，经过不少演变。从一开始的基本、到现在最新规范中一共有十七种属性值。此规范提出了两种显示类型，内部及外部。内部显示类型定义了元素内子元素的布局方式，外部显示类型则定义了元素怎样参与流式布局的处理。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("CSS在解析的过程，会计算出每个元素和文本节点的每个CSS属性值。浏览器就会靠其中的取值来判断要生成哪一类的盒子。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("CSS显示模块规范提出了两种显示类型，内部及外部。内部显示类型定义了元素内子元素的布局方式，外部显示类型则定义了元素怎样参与流式布局的处理。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"flex"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flex","aria-hidden":"true"}},[this._v("#")]),this._v(" Flex")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("然后慧晶老师提问到：“"),e("strong",[this._v("为什么块格式自动margin不垂直居中元素？")]),this._v("”")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("原因是如果元素的高度设为auto，那浏览器在计算它的高度时，只会考虑元素内容及子元素，纵向没有已确定的空间来调整位置。即使元素设了固定的高度，别忘记它跟子元素是互不相关的。这很有可能是浏览器最初执行的抉择遗留下来的行为。浏览器没办法计算上下方的margin取值，所以就把auto取值解析成0。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"容器–项目的「父子」关系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#容器–项目的「父子」关系","aria-hidden":"true"}},[this._v("#")]),this._v(" 容器–项目的「父子」关系")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("这是慧晶老师之前提到的转折点。因为flex或grid容器跟子元素的关系，在布局时是被浏览器承认的。因此，浏览器才有办法计算出四面的自动margin取值。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"css盒式对齐模块"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#css盒式对齐模块","aria-hidden":"true"}},[this._v("#")]),this._v(" CSS盒式对齐模块")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("在这一节，慧晶老师对CSS盒式对齐模块(CSS Box Alignment Level 3)进行了介绍。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("当然，光靠自动margin是不够的。要更精确的调整子元素的位置，我们可以运用盒式对齐模块（box alignment）提供的属性值。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("Flexbox的首个公开工作草案是在2009发布的，而Grid的则是2011发布。当时两个规范设定了两组不同的对齐属性。经过讨论，工作组决定把盒子对齐写成独立的规范，让过去、现在和未来的formatting contexts都统一使用相同的属性。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("Box alignment的属性一共有六个。在使用flex时，用得上其中四个，使用grid的话，六个属性全部都能用。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"grid或者flexbox"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#grid或者flexbox","aria-hidden":"true"}},[this._v("#")]),this._v(" Grid或者Flexbox?")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("“所以应该是用"),e("strong",[this._v("Gird")]),this._v("还是"),e("strong",[this._v("Flex")]),this._v("？”")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("这不是个二选一的状况，应该是二合一才对。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("Flexbox比较适合单维方向的布局。因为运用Flexbox来实现的行列，即使对齐了，也只是个假象。Flexbox的行跟列是互不相关的。但是在单维布局，它拥有最强的弹性功能。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("Grid则适合做二维网格布局，因为Grid中的行列才是真实的，才是是有关系的。你可以像在棋盘上排棋子似的，把Grid项目排成理想的布局。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("要实现类似上面布局的设计，用新时代布局方式是做得到的。要如何实现这种内容不对齐，环绕每个Grid单元厚厚的border？如果单靠Grid，用Box alignment属性，可以吗？")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("很可惜，做不到。之前有提过，Grid项目对齐的默认值是stretch。一旦用上任何以外的取值时，项目就会马上缩到内容的尺寸。可是如果我们在Grid项目上设一个display:flex，把它变成Flex容器。那表示Grid项目里面的内容，成为了Flex项目。现在利用Box alignment的各属性调整内容的位置就不会影响到Grid项目的尺寸，border也可以保持在Grid线上了。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"百分比的局限（一致性的伸缩率）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#百分比的局限（一致性的伸缩率）","aria-hidden":"true"}},[this._v("#")]),this._v(" 百分比的局限（一致性的伸缩率）")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("慧晶老师原话：“现在已经相当普遍的响应式网页设计，主要是依靠百分比来设定元素的尺寸。运用百分比的局限就是每个元素伸缩率是一致的。有时，这会导致开发者为了应付各种viewport尺寸范围，被逼要写数不清的media query。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("在深入研究这些新的布局模式时，我发现到最有趣的东西是灵活性尺寸。根据所设定的属性值，元素伸缩的变化率是有差别的。有些属性值会「坚持自己的立场」，在viewport变化的状况下，尽量保持范围内的宽度。这样讲有点难了解，还是看看一些用例吧。”")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("（鱼头注：关于上述属性对比，有兴趣的童鞋可以点击链接查看）")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"兼容处理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#兼容处理","aria-hidden":"true"}},[this._v("#")]),this._v(" 兼容处理")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("慧晶老师说：“Grid正式发布到现在，已经有大概两年的时间，浏览器的支持程度如今也高达88%，可以算是被广泛支持了。但是其它12%的用户该怎么办呢？”")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("上述问题其实CSS可以通过feature query做功能检测。它的语法类似media query，只是用的关键字是"),e("code",[this._v("@supports")])])}],!1,null,null,null);n.options.__file="new-layout.md";e.default=n.exports}}]);
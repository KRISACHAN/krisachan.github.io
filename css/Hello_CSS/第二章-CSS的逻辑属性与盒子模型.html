<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>【Hello CSS】第二章-CSS的逻辑属性与盒子模型 | 鱼头的海上世界</title>
    <meta name="description" content="kris&#39;s area">
    <link rel="icon" href="/favicon.ico">
    
    <link rel="preload" href="/assets/css/styles.2d46285b.css" as="style"><link rel="preload" href="/assets/js/app.2d46285b.js" as="script"><link rel="preload" href="/assets/js/9.72e54f0c.js" as="script"><link rel="prefetch" href="/assets/js/1.d84c28d0.js"><link rel="prefetch" href="/assets/js/10.70b4e5c0.js"><link rel="prefetch" href="/assets/js/11.b49678fa.js"><link rel="prefetch" href="/assets/js/12.732f6ab3.js"><link rel="prefetch" href="/assets/js/13.0128da3c.js"><link rel="prefetch" href="/assets/js/14.4322cce4.js"><link rel="prefetch" href="/assets/js/15.a3b815b7.js"><link rel="prefetch" href="/assets/js/16.db1a80ce.js"><link rel="prefetch" href="/assets/js/17.d8309b0d.js"><link rel="prefetch" href="/assets/js/18.d364e94c.js"><link rel="prefetch" href="/assets/js/19.98004734.js"><link rel="prefetch" href="/assets/js/2.1ffebd76.js"><link rel="prefetch" href="/assets/js/20.aa309836.js"><link rel="prefetch" href="/assets/js/21.f4cf1630.js"><link rel="prefetch" href="/assets/js/22.f4274640.js"><link rel="prefetch" href="/assets/js/23.b3641aaf.js"><link rel="prefetch" href="/assets/js/24.de9159e9.js"><link rel="prefetch" href="/assets/js/25.d68f3f4c.js"><link rel="prefetch" href="/assets/js/26.501b45f3.js"><link rel="prefetch" href="/assets/js/27.09b31a79.js"><link rel="prefetch" href="/assets/js/28.d7d55f06.js"><link rel="prefetch" href="/assets/js/3.e5da45d1.js"><link rel="prefetch" href="/assets/js/4.a037c934.js"><link rel="prefetch" href="/assets/js/5.efbc6977.js"><link rel="prefetch" href="/assets/js/6.18bf3204.js"><link rel="prefetch" href="/assets/js/7.7adeedf9.js"><link rel="prefetch" href="/assets/js/8.03d7a33b.js">
    <link rel="stylesheet" href="/assets/css/styles.2d46285b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/" class="home-link router-link-active"><!----><span class="site-name">
      鱼头的海上世界
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><!----></div></header><div class="sidebar-mask"></div><div class="sidebar"><!----><ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>【Hello CSS】第二章-CSS的逻辑属性与盒子模型</span><!----></p><ul class="sidebar-group-items"><li><a href="/css/Hello_CSS/%E7%AC%AC%E4%BA%8C%E7%AB%A0-CSS%E7%9A%84%E9%80%BB%E8%BE%91%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.html#css的逻辑属性" class="sidebar-link">CSS的逻辑属性</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/css/Hello_CSS/%E7%AC%AC%E4%BA%8C%E7%AB%A0-CSS%E7%9A%84%E9%80%BB%E8%BE%91%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.html#writing-mode" class="sidebar-link">writing-mode</a></li><li class="sidebar-sub-header"><a href="/css/Hello_CSS/%E7%AC%AC%E4%BA%8C%E7%AB%A0-CSS%E7%9A%84%E9%80%BB%E8%BE%91%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.html#新旧逻辑属性对比" class="sidebar-link">新旧逻辑属性对比</a></li><li class="sidebar-sub-header"><a href="/css/Hello_CSS/%E7%AC%AC%E4%BA%8C%E7%AB%A0-CSS%E7%9A%84%E9%80%BB%E8%BE%91%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.html#css定位" class="sidebar-link">CSS定位</a></li><li class="sidebar-sub-header"><a href="/css/Hello_CSS/%E7%AC%AC%E4%BA%8C%E7%AB%A0-CSS%E7%9A%84%E9%80%BB%E8%BE%91%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.html#css浮动" class="sidebar-link">CSS浮动</a></li><li class="sidebar-sub-header"><a href="/css/Hello_CSS/%E7%AC%AC%E4%BA%8C%E7%AB%A0-CSS%E7%9A%84%E9%80%BB%E8%BE%91%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.html#text-align" class="sidebar-link">text-align</a></li><li class="sidebar-sub-header"><a href="/css/Hello_CSS/%E7%AC%AC%E4%BA%8C%E7%AB%A0-CSS%E7%9A%84%E9%80%BB%E8%BE%91%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.html#direction" class="sidebar-link">direction</a></li></ul></li><li><a href="/css/Hello_CSS/%E7%AC%AC%E4%BA%8C%E7%AB%A0-CSS%E7%9A%84%E9%80%BB%E8%BE%91%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.html#css的盒子模型" class="sidebar-link">CSS的盒子模型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/css/Hello_CSS/%E7%AC%AC%E4%BA%8C%E7%AB%A0-CSS%E7%9A%84%E9%80%BB%E8%BE%91%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.html#基础盒模型-css-basic-box-model" class="sidebar-link">基础盒模型(CSS basic box model)</a></li><li class="sidebar-sub-header"><a href="/css/Hello_CSS/%E7%AC%AC%E4%BA%8C%E7%AB%A0-CSS%E7%9A%84%E9%80%BB%E8%BE%91%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.html#盒子模型的值" class="sidebar-link">盒子模型的值</a></li><li class="sidebar-sub-header"><a href="/css/Hello_CSS/%E7%AC%AC%E4%BA%8C%E7%AB%A0-CSS%E7%9A%84%E9%80%BB%E8%BE%91%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.html#视觉格式化模型-visual-formatting-model" class="sidebar-link">视觉格式化模型(visual formatting model)</a></li><li class="sidebar-sub-header"><a href="/css/Hello_CSS/%E7%AC%AC%E4%BA%8C%E7%AB%A0-CSS%E7%9A%84%E9%80%BB%E8%BE%91%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.html#参考资料：" class="sidebar-link">参考资料：</a></li></ul></li><li><a href="/css/Hello_CSS/%E7%AC%AC%E4%BA%8C%E7%AB%A0-CSS%E7%9A%84%E9%80%BB%E8%BE%91%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.html#结语" class="sidebar-link">结语</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/css/Hello_CSS/%E7%AC%AC%E4%BA%8C%E7%AB%A0-CSS%E7%9A%84%E9%80%BB%E8%BE%91%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.html#【hello-css】系列" class="sidebar-link">【Hello CSS】系列</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/css/Hello_CSS/%E7%AC%AC%E4%BA%8C%E7%AB%A0-CSS%E7%9A%84%E9%80%BB%E8%BE%91%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.html#下一篇" class="sidebar-link">下一篇</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/css/Hello_CSS/%E7%AC%AC%E4%BA%8C%E7%AB%A0-CSS%E7%9A%84%E9%80%BB%E8%BE%91%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.html#历史文章传送门" class="sidebar-link">历史文章传送门</a><ul class="sidebar-sub-headers"></ul></li></ul></div></li></ul></div><div class="page"><div class="content"><h1 id="【hello-css】第二章-css的逻辑属性与盒子模型"><a href="#【hello-css】第二章-css的逻辑属性与盒子模型" aria-hidden="true" class="header-anchor">#</a> 【Hello CSS】第二章-CSS的逻辑属性与盒子模型</h1><blockquote><ul><li>作者：陈大鱼头</li><li>github： <a href="https://github.com/KRISACHAN" target="_blank" rel="noopener noreferrer">KRISACHAN<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></blockquote><p>在上一篇<code>【Hello CSS】</code>的第一章<a href="/css/Hello_CSS/第一章-CSS的语法与工作流.html">CSS的语法与工作流</a>中介绍了<code>CSS</code>的语法规则以及基本的渲染流程。本篇则会分享<code>CSS</code>的逻辑属性以及盒子模型。</p><p>首先开篇之前先提个问题：<br></p><p><strong>为什么<code>Flex box</code>跟<code>Grid box</code>的是以<code>start</code>、<code>end</code>为排列规则，而不是常规的<code>top</code> 、<code>right</code> 、<code>bottom</code> 跟<code>left</code>？</strong></p><p>先不要急着往下翻，大家先思考一下。</p><p>这个问题的答案，鱼头会在文章中给出，欢迎大家带着这个问题往下翻阅，如果已经知道答案，也可以看看跟大家所知道的答案是否一致。</p><h2 id="css的逻辑属性"><a href="#css的逻辑属性" aria-hidden="true" class="header-anchor">#</a> CSS的逻辑属性</h2><blockquote><p>2017年5月18日，W3C的 <a href="https://www.w3.org/Stlye/CSS/Members/" target="_blank" rel="noopener noreferrer">CSS工作组(CSS Working Group)<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 发布了 <a href="https://www.w3.org/TR/2017/WD-css-logical-1-20170518/" target="_blank" rel="noopener noreferrer">CSS逻辑属性和值(CSS Logical Properties and Values Level 1)<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的首份工作草案(First Public Working Draft)。不同的书写模式(writing mode)中，可以抽取出共性的抽象概念(如开始位置，或行)，这些逻辑抽象概念需要在不同书写模式下映射到左或右、上或下等物理的概念上。一些CSS布局可能依赖这些共性的逻辑概念。该 CSS 模块给出了用于通过逻辑方式(而不是基于物理坐标、书写方向和维映射等)控制布局的逻辑属性和取值(logical properties and values)。这个模块来源于CSS21中关于逻辑属性和值的特性。</p></blockquote><p>上面复制粘贴了<a href="http://www.chinaw3c.org/archives/1820/" target="_blank" rel="noopener noreferrer">W3C 中国<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>里的内容。</p><p>对于前端来说，我们一直习惯于使用<code>top</code> 、 <code>right</code> 、 <code>bottom</code>、 <code>left</code>来定义我们的<code>HTML</code>元素，这跟我们物理上的概念是一致的。但是对于<code>CSS</code>这个原本是为了服务于图文展示才诞生的语言来说，其实是不匹配的，为什么这么说？</p><h3 id="writing-mode"><a href="#writing-mode" aria-hidden="true" class="header-anchor">#</a> writing-mode</h3><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/writing-mode" target="_blank" rel="noopener noreferrer">writing-mode<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：定义了文本水平或垂直排布以及在块级元素中文本的行进方向。</p></blockquote><p><code>writing-mode</code>一共有以下5个改变<code>HTML</code>文本书写规则的值(还有几个是用在<code>SVG</code>上的，本文不予讨论)：</p><h4 id="writing-mode-horizontal-tb"><a href="#writing-mode-horizontal-tb" aria-hidden="true" class="header-anchor">#</a> writing-mode: horizontal-tb;</h4><p><code>writing-mode: horizontal-tb</code> 定义了内容从左到右水平流动，从上到下垂直流动。下一条水平线位于上一条线下方。</p><h4 id="writing-mode-vertical-rl"><a href="#writing-mode-vertical-rl" aria-hidden="true" class="header-anchor">#</a> writing-mode: vertical-rl;</h4><p><code>writing-mode: vertical-rl</code> 定义了内容从上到下垂直流动，从右到左水平流动。下一条垂直线位于上一行的左侧。</p><h4 id="writing-mode-vertical-lr"><a href="#writing-mode-vertical-lr" aria-hidden="true" class="header-anchor">#</a> writing-mode: vertical-lr;</h4><p><code>writing-mode: vertical-lr</code>定义了内容从上到下垂直流动，从左到右水平流动。下一条垂直线位于上一行的右侧。</p><h4 id="writing-mode-sideways-rl-仅firefox41-实现"><a href="#writing-mode-sideways-rl-仅firefox41-实现" aria-hidden="true" class="header-anchor">#</a> writing-mode: sideways-rl; (仅Firefox41+实现)</h4><p><code>writing-mode: sideways-rl</code>定义了内容从上到下垂直流动，所有字形，甚至是垂直脚本中的字形，都设置在右侧。</p><h4 id="writing-mode-sideways-lr-仅firefox41-实现"><a href="#writing-mode-sideways-lr-仅firefox41-实现" aria-hidden="true" class="header-anchor">#</a> writing-mode: sideways-lr;(仅Firefox41+实现)</h4><p><code>writing-mode: sideways-lr</code>内容从上到下垂直流动，所有字形，甚至是垂直脚本中的字形，都设置在左侧。</p><br><p><strong>上述效果请看<a href="/css/css-writing-mode.html">DEMO</a></strong></p><p>源码如下：</p><div class="language-html extra-class"><pre class="language-html"><code>.wm-htb {
	writing-mode: horizontal-tb;
}
.wm-vrl {
	writing-mode: vertical-rl;
}
.wm-vlr {
	writing-mode: vertical-lr;
}
.wm-srl {
	writing-mode: sideways-rl;
}
.wm-slr {
	writing-mode: sideways-lr;
}
.text-content {
    width: 200px;
    padding: 20px;
    border: 1px solid;
    display: inline-block;
    vertical-align: top;
    padding-right: 100px;
}

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>text-content wm-htb<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>writing-mode: horizontal-tb;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>text-content wm-vrl<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>writing-mode: vertical-rl;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>text-content wm-vlr<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>writing-mode: vertical-lr;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>text-content wm-srl<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>writing-mode: sideways-rl;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>text-content wm-slr<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>writing-mode: sideways-lr;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>图示如下：</p><img src="/img/Hello_CSS/css_writing-mode.png" style="margin: 0 auto;display: block; font-size: 0; vertical-align: middle;"><p>从上图可以发现，当我们设置了<code>padding-right: 100px;</code>的时候，不同的书写规则，展示效果是不一样的。</p><p>在最开始的时候，<code>HTML</code>与<code>CSS</code>只服务于英语国家，但是随着互联网的发展，逐渐各个不同书写规则的国家也开始流行了起来。</p><p>我们原来的<code>CSS</code>逻辑属性是按照物理逻辑，从上(top)、右(right)、下(bottom)、左(left)划分的。</p><p>那么按着这个规则去修改文本属性时，就会出现上述这种不符合语法规则的状态。</p><p>大概也是基于这个原因，所以<a href="http://www.chinaw3c.org/archives/1820/" target="_blank" rel="noopener noreferrer">W3C<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>发布了新的逻辑属性与值。</p><h3 id="新旧逻辑属性对比"><a href="#新旧逻辑属性对比" aria-hidden="true" class="header-anchor">#</a> 新旧逻辑属性对比</h3><blockquote><p>CSS新旧逻辑属性是完全不同的两种模型。</p></blockquote><p>我们首先来看看新旧有的逻辑属性的对比图示(图片来自<a href="https://medium.com/@elad/new-css-logical-properties-bc6945311ce7" target="_blank" rel="noopener noreferrer">medium<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>)：</p><img src="/img/Hello_CSS/css_technique.png" style="margin: 0 auto;display: block; font-size: 0; vertical-align: middle;"><p align="center">左旧右新</p><p>通过上图可以得知新旧逻辑属性对应关系如下：</p><table><thead><tr><th>旧的逻辑属性</th><th>新的逻辑属性</th></tr></thead><tbody><tr><td>margin-top</td><td>margin-block-start</td></tr><tr><td>margin-right</td><td>margin-inline-end</td></tr><tr><td>margin-bottom</td><td>margin-block-end</td></tr><tr><td>margin-left</td><td>margin-inline-start</td></tr><tr><td>border-top</td><td>border-block-start</td></tr><tr><td>border-right</td><td>border-inline-end</td></tr><tr><td>border-bottom</td><td>border-block-end</td></tr><tr><td>border-left</td><td>border-inline-start</td></tr><tr><td>padding-top</td><td>padding-block-start</td></tr><tr><td>padding-right</td><td>padding-inline-end</td></tr><tr><td>padding-bottom</td><td>padding-block-end</td></tr><tr><td>padding-left</td><td>padding-inline-start</td></tr><tr><td>width</td><td>inline-size</td></tr><tr><td>height</td><td>block-size</td></tr></tbody></table><p>由上表可以得知，把<strong>Y轴</strong>方向的属性都改为了<strong>block</strong>，<strong>X轴</strong>方向的属性都改为了<strong>inline</strong>。</p><p>对于不同语系的国家，书写顺序会可能有很大的差异，意思就是<code>block</code>跟<code>inline</code>的方向不同。例如：</p><ul><li>在英语国家 <code>padding-inline-start</code> = <code>padding-left</code></li><li>在阿拉伯<code>padding-inline-start</code> = <code>padding-right</code></li><li>在日本 <code>padding-inline-start</code> = <code>padding-top</code></li></ul><p>这就意味着旧的逻辑属性，在某些国家里会变得不合常理。</p><h3 id="css定位"><a href="#css定位" aria-hidden="true" class="header-anchor">#</a> CSS定位</h3><p><code>CSS</code>的定位属性变化如下：</p><table><thead><tr><th>旧的逻辑属性</th><th>新的逻辑属性</th></tr></thead><tbody><tr><td>top</td><td>inset-block-start</td></tr><tr><td>bottom</td><td>inset-block-end</td></tr><tr><td>left</td><td>inset-inline-start</td></tr><tr><td>right</td><td>inset-inline-end</td></tr></tbody></table><p>例子如下：</p><div class="language-CSS extra-class"><pre class="language-css"><code><span class="token comment">/* 旧的逻辑属性 */</span>
<span class="token selector">.popup</span><span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span>fixed<span class="token punctuation">;</span>  
  <span class="token property">top</span><span class="token punctuation">:</span>0<span class="token punctuation">;</span>
  <span class="token property">bottom</span><span class="token punctuation">:</span>0<span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span>0<span class="token punctuation">;</span>
  <span class="token property">right</span><span class="token punctuation">:</span>0<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/* 新的逻辑属性 */</span>
<span class="token selector">.popup</span><span class="token punctuation">{</span>
   <span class="token property">position</span><span class="token punctuation">:</span>fixed<span class="token punctuation">;</span>
   <span class="token property">inset-block-start</span><span class="token punctuation">:</span>0<span class="token punctuation">;</span>  <span class="token comment">/*top - in English*/</span>
   <span class="token property">inset-block-end</span><span class="token punctuation">:</span>0<span class="token punctuation">;</span>    <span class="token comment">/*bottom - in English*/</span>
   <span class="token property">inset-inline-start</span><span class="token punctuation">:</span>0<span class="token punctuation">;</span> <span class="token comment">/*left - in English*/</span>
   <span class="token property">inset-inline-end</span><span class="token punctuation">:</span>0<span class="token punctuation">;</span>   <span class="token comment">/*right - in English*/</span>
<span class="token punctuation">}</span>
<span class="token comment">/* 新的逻辑属性支持简写 */</span>
<span class="token selector">.popup</span><span class="token punctuation">{</span>
   <span class="token property">position</span><span class="token punctuation">:</span>fixed<span class="token punctuation">;</span>
   <span class="token property">inset</span><span class="token punctuation">:</span>0 0 0 0<span class="token punctuation">;</span>   <span class="token comment">/*top, right, bottom, left - in English*/</span>
<span class="token punctuation">}</span>
</code></pre></div><p>图示：(图片来自<a href="https://medium.com/@elad/new-css-logical-properties-bc6945311ce7" target="_blank" rel="noopener noreferrer">medium<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>)：</p><img src="/img/Hello_CSS/old_technique.png" style="margin: 0 auto;display: block; font-size: 0; vertical-align: middle;"><br><img src="/img/Hello_CSS/new_technique.png" style="margin: 0 auto;display: block; font-size: 0; vertical-align: middle;"><h3 id="css浮动"><a href="#css浮动" aria-hidden="true" class="header-anchor">#</a> CSS浮动</h3><p>浮动<code>float</code>的属性也改了。</p><table><thead><tr><th>旧的逻辑属性</th><th>新的逻辑属性</th></tr></thead><tbody><tr><td>float: left</td><td>float: inline-start</td></tr><tr><td>float: right</td><td>float: inline-end</td></tr></tbody></table><h3 id="text-align"><a href="#text-align" aria-hidden="true" class="header-anchor">#</a> text-align</h3><p>文本<code>text-align</code>的属性也改了。</p><table><thead><tr><th>旧的逻辑属性</th><th>新的逻辑属性</th></tr></thead><tbody><tr><td>text-align: left</td><td>text-align: start</td></tr><tr><td>text-align: right</td><td>text-align: end</td></tr></tbody></table><h3 id="direction"><a href="#direction" aria-hidden="true" class="header-anchor">#</a> direction</h3><p>除了<code>writing-mode</code>，还有一个排版属性就是<code>direction</code>，跟<code>writing-mode</code>类似，不一样的是<code>writing-mode</code>是控住网页布局方向的，而<code>direction</code>是控制文本对齐方向的。属性如下：</p><h4 id="direction-ltr"><a href="#direction-ltr" aria-hidden="true" class="header-anchor">#</a> direction: ltr;</h4><p>默认值，让文本和其他元素从左到右显示。</p><h4 id="direction-rtl"><a href="#direction-rtl" aria-hidden="true" class="header-anchor">#</a> direction: rtl;</h4><p>让文本和其他元素从右到左显示。</p><br><p><strong>吐槽一下，看到这里的切图仔们，抓紧 <s>跑路</s> 重构吧，等哪天此属性正式被启用，就真的GG了。不过我想应该会立个属性来选择性开启物理属性还是逻辑属性，不然这对前端来说将会是一场灾难！</strong></p><h2 id="css的盒子模型"><a href="#css的盒子模型" aria-hidden="true" class="header-anchor">#</a> CSS的盒子模型</h2><h3 id="基础盒模型-css-basic-box-model"><a href="#基础盒模型-css-basic-box-model" aria-hidden="true" class="header-anchor">#</a> 基础盒模型(CSS basic box model)</h3><p>当浏览器对一个<strong>render tree</strong>进行渲染时，浏览器的渲染引擎就会根据<strong>基础盒模型(CSS basic box model)</strong>，将所有元素划分为一个个矩形的盒子，这些盒子的外观，属性由<code>CSS</code>来决定。</p><p>我们在浏览器控制台输入如下代码就可以看到页面的每一个元素都是由一个矩形来包裹的，这些就是<strong>盒子</strong></p><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">$$</span><span class="token punctuation">(</span><span class="token string">'*'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>e <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  e<span class="token punctuation">.</span>style<span class="token punctuation">.</span>border <span class="token operator">=</span> <span class="token string">'1px solid'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>图示如下：</p><img src="/img/Hello_CSS/css_box.png" style="margin: 0 auto;display: block; font-size: 0; vertical-align: middle;"><br><p><strong>每个盒子都由四个部分组成：</strong></p><h4 id="内容-content"><a href="#内容-content" aria-hidden="true" class="header-anchor">#</a> 内容(content)</h4><p><strong>盒子(box)</strong> 的内容，显示标签内一切的文本，图案或者别的内容。</p><h4 id="内边距-padding"><a href="#内边距-padding" aria-hidden="true" class="header-anchor">#</a> 内边距(padding)</h4><p><strong>盒子(box)</strong> 内的填充物，样式为透明，主要负责扩展盒子内区域大小。</p><h4 id="外边距-margin"><a href="#外边距-margin" aria-hidden="true" class="header-anchor">#</a> 外边距(margin)</h4><p><strong>盒子(box)</strong> 外部的区域，样式为透明，负责隔离相邻的元素。</p><h4 id="边框-border"><a href="#边框-border" aria-hidden="true" class="header-anchor">#</a> 边框(border)</h4><p><strong>盒子(box)</strong> 的边界，负责隔离外边距以及内边距。</p><h3 id="盒子模型的值"><a href="#盒子模型的值" aria-hidden="true" class="header-anchor">#</a> 盒子模型的值</h3><p><strong>盒子模型一共有三个值：</strong></p><h4 id="content-box"><a href="#content-box" aria-hidden="true" class="header-anchor">#</a> content-box</h4><p><code>content-box</code>为标准的盒子模型。盒子的<code>width</code>跟<code>height</code>只包括盒子本身的<code>width</code>与<code>height</code>属性。</p><p>计算法则：</p><p><code>width = width</code></p><p><code>height = height</code></p><h4 id="border-box"><a href="#border-box" aria-hidden="true" class="header-anchor">#</a> border-box</h4><p><code>border-box</code>为盒子模型可选的属性之一。盒子的<code>width</code>跟<code>height</code>包括<code>content</code>、<code>padding</code>跟<code>border</code>。这也是当文档处于 Quirks模式 时Internet Explorer使用的盒模型。</p><p>计算法则：</p><p><code>width = width + border + padding</code></p><p><code>height = height + border + padding</code></p><h4 id="padding-box"><a href="#padding-box" aria-hidden="true" class="header-anchor">#</a> padding-box</h4><p><code>padding-box</code>为非标准属性，曾经在<strong>Firefox</strong>中实现过，但是在<strong>Firefox 50</strong>中被删除。<code>padding-box</code>的<code>width</code>和<code>height</code> 属性包括内容和内边距，但是不包括边框和外边距。</p><p>图示：</p><img src="/img/Hello_CSS/css_box-sizing.png" style="margin: 0 auto;display: block; font-size: 0; vertical-align: middle;"><p><strong>这里吐槽一下，不知道为何没有margin-box，虽然并没有太大意义，当真实现了效果估计也很诡异，但是作为一个强迫症患者晚期，少了一个属性总感觉好不舒服。</strong></p><h3 id="视觉格式化模型-visual-formatting-model"><a href="#视觉格式化模型-visual-formatting-model" aria-hidden="true" class="header-anchor">#</a> 视觉格式化模型(visual formatting model)</h3><blockquote><p><code>CSS</code>的<strong>视觉格式化模型(visual formatting model)</strong> 是根据 <strong>基础盒模型(CSS basic box model)</strong> 将 <strong>文档(doucment)</strong> 中的元素转换一个个盒子的实际算法。</p><p>官方说法就是：<strong>它规定了用户端在媒介中如何处理文档树( document tree )。</strong></p></blockquote><p>每个盒子的布局由以下因素决定：</p><ul><li>盒子的尺寸</li><li>盒子的类型：<strong>行内盒子 (inline)</strong>、<strong>行内级盒子 (inline-level)</strong>、<strong>原子行内级盒子 (atomic inline-level)</strong>、<strong>块级盒子 (block-level)</strong></li><li>定位：<strong>普通流</strong>、<strong>浮动</strong>、<strong>绝对定位</strong></li><li>文档树中当前盒子的<strong>子元素</strong> 或 <strong>兄弟元素</strong></li><li><strong>视口(viewport)</strong> 的<strong>尺寸</strong> 和<strong>位置</strong></li><li>盒子内部图片的<strong>尺寸</strong></li><li>其他某些外部因素</li></ul><p><strong>视觉格式化模型(visual formatting model)</strong>  的计算，都取决于一个矩形的边界，这个矩形，被称作是 <strong>包含块( containing block )</strong> 。 一般来说，(元素)生成的框会扮演它子孙元素包含块的角色；我们称之为：一个(元素的)框为它的子孙节点建造了包含块。包含块是一个相对的概念。</p><p>例子如下：</p><div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>hi<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>以上代码为例，<code>div</code> 和 <code>table</code> 都是包含块。<code>div</code> 是 <code>table</code> 的包含块，同时 <code>table</code> 又是 <code>td</code> 的包含块，不是绝对的。</p><p>图示：(图片来自<a href="http://w3help.org/zh-cn/kb/008/" target="_blank" rel="noopener noreferrer">w3help<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>)：</p><img src="/img/Hello_CSS/css_containing_blocks.png" style="margin: 0 auto;display: block; font-size: 0; vertical-align: middle;"><h4 id="盒子的生成"><a href="#盒子的生成" aria-hidden="true" class="header-anchor">#</a> 盒子的生成</h4><blockquote><p>盒子的生成是 <strong>CSS视觉格式化模型</strong> 的一部分，用于从文档元素生成盒子。盒子的类型取决于<code>CSS display</code> 属性。</p></blockquote><ul><li><p>块级元素</p><ul><li>当元素的<code>display</code>  为 <code>block</code>、<code>list-item</code> 或 <code>table</code> 时，它就是块级元素。</li></ul></li><li><p>块级盒子</p><ul><li>块级盒子用于描述它与父、兄弟元素之间的关系。</li><li>每个块级盒子都会参与 <strong>块格式化上下文（block formatting context）</strong> 的创建。</li><li>每个块级元素都会至少生成一个块级盒子，即<strong>主块级盒子（principal block-level box）</strong></li><li>主块级盒子包含由后代元素生成的盒子以及内容，同时它也会参与定位方案。</li><li>一个同时是块容器盒子的块级盒子称为<strong>块盒子（block box）</strong>。</li></ul></li><li><p>匿名盒子</p><ul><li>某些情况下需要进行视觉格式化时，需要添加一些增补性的盒子，这些盒子不能被<code>CSS 选择器</code>选中，也就是所有可继承的 CSS 属性值都为 <code>inherit</code> ，而所有不可继承的 CSS 属性值都为 <code>initial</code>。因此称为<strong>匿名盒子(anonymous boxes)</strong>。</li></ul></li><li><p>行内元素</p><ul><li>当元素的<code>display</code>  为 <code>inline</code>、<code>inline-block</code> 或 <code>inline-table</code> 时，它就是行内级元素。</li><li>显示时可以与其他行内级内容一起显示为多行。</li></ul></li><li><p>行内盒子</p><ul><li>行内级元素会生成行内级盒子，该盒子同时会参与<code>行内格式化上下文（inline formatting context）</code>的创建。</li></ul></li><li><p>匿名行内盒子</p><ul><li>类似于块盒子，CSS引擎有时候也会自动创建一些行内盒子。这些行内盒子无法被选择符选中，因此是匿名的，它们从父元素那里继承那些可继承的属性，其他属性保持默认值 <code>initial</code>。</li></ul></li><li><p>行盒子</p><ul><li>行盒子由行内格式化上下文创建，用来显示一行文本。在块盒子内部，行盒子总是从块盒子的一边延伸到另一边（译注：即占据整个块盒子的宽度）。当有浮动元素时，行盒子会从向左浮动的元素的右边缘延伸到向右浮动的元素的左边缘。</li></ul></li><li><p>run-in 盒子（在CSS 2.1的标准中移除了）</p><ul><li>run-in盒子可以通过<code>display: run-in</code>来设置，它既可以是块盒子，又可以是行内盒子，这取决于它后面的盒子的类型。</li></ul></li></ul><h4 id="定位规则"><a href="#定位规则" aria-hidden="true" class="header-anchor">#</a> 定位规则</h4><blockquote><p>一旦形成了盒子，CSS引擎就需要定位它们来完成布局。</p></blockquote><p>定位所使用的规则如下：</p><ul><li>普通流
<ul><li>在普通流中，盒子会依次放置。</li><li>在**块格式化上下文（block formatting context）**中，盒子在垂直方向依次排列。</li><li>在<strong>行内格式化上下文（inline formatting context）</strong> 中，盒子则水平摆列。</li></ul></li><li>浮动：当一个盒子的<code>float</code>不为<code>none</code>，并且<code>position</code>为<code>static</code>或<code>relative</code>时，该盒子为浮动定位。
<ul><li><code>float: left</code>：盒子会定位到当前行盒子的开始位置（左侧）。</li><li><code>float: right</code>：盒子会定位到当前行盒子的尾部位置（右侧）。</li></ul></li><li>绝对定位：如果元素的<code>position</code> 为 <code>absolute</code> 或 <code>fixed</code>，该元素为绝对定位。
<ul><li>在绝对定位中，盒子会完全从当前流中移除，并且不会再与其有任何联系。</li></ul></li></ul><h3 id="参考资料："><a href="#参考资料：" aria-hidden="true" class="header-anchor">#</a> 参考资料：</h3><p><a href="http://www.chinaw3c.org/archives/1820/" target="_blank" rel="noopener noreferrer">W3C 中国<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p><a href="https://medium.com/@elad/new-css-logical-properties-bc6945311ce7" target="_blank" rel="noopener noreferrer">New CSS Logical Properties!<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p><a href="http://w3help.org/zh-cn/kb/008/" target="_blank" rel="noopener noreferrer">w3help<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p><a href="https://segmentfault.com/a/1190000008541494" target="_blank" rel="noopener noreferrer">视觉格式化模型(Visual formatting model)<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Visual_formatting_model" target="_blank" rel="noopener noreferrer">MDN 视觉格式化模型<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p><a href="http://w3help.org/zh-cn/kb/008/" target="_blank" rel="noopener noreferrer">包含块( Containing block )<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><h2 id="结语"><a href="#结语" aria-hidden="true" class="header-anchor">#</a> 结语</h2><p>本篇文章主要介绍了<code>CSS</code>的新旧逻辑属性的状态以及盒子模型的具体情况。文章内还有部分内容没有进行太多的介绍，例如<strong>块格式化上下文（block formatting context）</strong> 跟 <strong>行内格式化上下文（inline formatting context）<strong>以及其他一些具体的名称，这些后续的文章都将会进行介绍，到时候将会进行具体的讲解，希望大家可以多多关注鱼头我的</strong>【Hello CSS】系列</strong>。</p><p>开头时，鱼头我有问到大家一个问题，就是：</p><p><strong>为什么<code>Flex box</code>跟<code>Grid box</code>的是以<code>start</code>、<code>end</code>为排列规则，而不是常规的<code>top</code> 、<code>right</code> 、<code>bottom</code> 跟<code>left</code>？</strong></p><p>这个问题，通过本篇文章的分享，大家有答案了吗？</p><p>鱼头我将会在下一篇开头时分享答案，希望大家多多留意本系列文章。</p><h2 id="【hello-css】系列"><a href="#【hello-css】系列" aria-hidden="true" class="header-anchor">#</a> 【Hello CSS】系列</h2><p><code>【Hello CSS】</code>是以<code>CSS</code>基础概念为主题的系列文章，旨在帮助大家更深刻地了解并且提高<code>CSS</code>在各位开发者心目中的地位。由于鱼头我水平有限，文笔有限，如果各位在文章中发现有任何不合理，不正确的地方，还烦不吝指出，我会非常感谢的；如果通过文章有任何想法或疑问，也希望各位能积极留言，我们互相探讨；如果通过本系列文章有所收获，这就让鱼头我喜不自胜了！</p><br><br>
如果你也喜欢`CSS`，喜欢探讨技术，或者对本文，本系列有任何的意见或建议，你可以扫描下方二维码，关注微信公众号“<b>鱼头的Web海洋</b>”，随时与鱼头互动。欢迎！衷心希望可以遇见你。
<br><br><img src="/img/qrcode-base.png" style="margin: 24px auto;display: block; font-size: 0; vertical-align: middle; width: 100%;"><h2 id="下一篇"><a href="#下一篇" aria-hidden="true" class="header-anchor">#</a> 下一篇</h2><ol start="4"><li><a href="/css/Hello_CSS/第三章-浏览器的视图与坐标.html">第三章-浏览器的视图与坐标</a></li></ol><h2 id="历史文章传送门"><a href="#历史文章传送门" aria-hidden="true" class="header-anchor">#</a> 历史文章传送门</h2><ol><li><p><a href="/css/Hello_CSS/序章-CSS起源.html">序章-起源</a></p></li><li><p><a href="/css/Hello_CSS/第一章-CSS的语法与工作流.html">第一章-CSS的语法与工作流</a></p></li><li><p><a href="/css/Hello_CSS/第二章-CSS的逻辑属性与盒子模型.html">第二章-CSS的逻辑属性与盒子模型</a></p></li></ol></div><div class="page-edit"><!----><!----></div><!----></div></div></div>
    <script src="/assets/js/app.2d46285b.js" defer></script><script src="/assets/js/9.72e54f0c.js" defer></script>
  </body>
</html>
